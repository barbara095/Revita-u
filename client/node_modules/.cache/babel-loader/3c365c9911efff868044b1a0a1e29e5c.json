{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport VirtualList from 'react-tiny-virtual-list';\nimport debounce from 'lodash.debounce';\nimport { Pane } from '../../layers';\nimport { useForceUpdate } from '../../hooks';\nvar TableVirtualBody = memo(function TableVirtualBody(props) {\n  var inputChildren = props.children,\n      paneHeight = props.height,\n      _props$defaultHeight = props.defaultHeight,\n      defaultHeight = _props$defaultHeight === void 0 ? 48 : _props$defaultHeight,\n      _props$allowAutoHeigh = props.allowAutoHeight,\n      allowAutoHeight = _props$allowAutoHeigh === void 0 ? false : _props$allowAutoHeigh,\n      _props$overscanCount = props.overscanCount,\n      overscanCount = _props$overscanCount === void 0 ? 5 : _props$overscanCount,\n      estimatedItemSize = props.estimatedItemSize,\n      _props$useAverageAuto = props.useAverageAutoHeightEstimation,\n      useAverageAutoHeightEstimation = _props$useAverageAuto === void 0 ? true : _props$useAverageAuto,\n      scrollToIndex = props.scrollToIndex,\n      scrollOffset = props.scrollOffset,\n      scrollToAlignment = props.scrollToAlignment,\n      onScroll = props.onScroll,\n      rest = _objectWithoutProperties(props, [\"children\", \"height\", \"defaultHeight\", \"allowAutoHeight\", \"overscanCount\", \"estimatedItemSize\", \"useAverageAutoHeightEstimation\", \"scrollToIndex\", \"scrollOffset\", \"scrollToAlignment\", \"onScroll\"]);\n\n  var forceUpdate = useForceUpdate();\n  var autoHeights = [];\n  var autoHeightRefs = [];\n  var averageAutoHeight = defaultHeight;\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      paneRef = _useState2[0],\n      setPaneRef = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isIntegerHeight = _useState4[0],\n      setIsIntegerHeight = _useState4[1];\n\n  var _useState5 = useState(0),\n      _useState6 = _slicedToArray(_useState5, 2),\n      calculatedHeight = _useState6[0],\n      setCalculatedHeight = _useState6[1];\n\n  var updateOnResize = function updateOnResize() {\n    autoHeights = [];\n    autoHeightRefs = [];\n    averageAutoHeight = defaultHeight; // Simply return when we now the height of the pane is fixed.\n\n    if (isIntegerHeight) return; // Return if we are in a weird edge case in which the ref is no longer valid.\n\n    if (paneRef && paneRef instanceof Node) {\n      var tempCalculatedHeight = paneRef.offsetHeight;\n\n      if (tempCalculatedHeight > 0) {\n        // Save the calculated height which is needed for the VirtualList.\n        setCalculatedHeight(tempCalculatedHeight); // Prevent updateOnResize being called recursively when there is a valid height.\n\n        return;\n      }\n    } // When height is still 0 (or paneRef is not valid) try recursively until success.\n\n\n    requestAnimationFrame(function () {\n      updateOnResize();\n    });\n  };\n\n  var onResize = debounce(updateOnResize, 200);\n  useEffect(function () {\n    if (props.height !== calculatedHeight) {\n      setIsIntegerHeight(Number.isInteger(props.height));\n    }\n  }, [props.height]);\n  useEffect(function () {\n    if (paneRef && paneRef instanceof Node) {\n      updateOnResize();\n    }\n  }, [paneRef]); // Mirrors functionality of componentDidMount and componentWillUnmount.\n  // By passing an empty array, will only run on first render, the function returned\n  // will be called on component unmount\n\n  useEffect(function () {\n    updateOnResize();\n    window.addEventListener('resize', onResize, false);\n    return function () {\n      window.removeEventListener('resize', onResize);\n    };\n  }, []);\n  /**\n   * This function will process all items that have height=\"auto\" set.\n   * It will loop through all refs and get calculate the height.\n   */\n\n  var processAutoHeights = function processAutoHeights() {\n    var isUpdated = false; // This will determine the averageAutoHeight.\n\n    var total = 0;\n    var totalAmount = 0; // Loop through all of the refs that have height=\"auto\".\n\n    autoHeightRefs.forEach(function (ref, index) {\n      // If the height is already calculated, skip it,\n      // but calculate the height for the total.\n      if (autoHeights[index]) {\n        total += autoHeights[index];\n        totalAmount += 1;\n        return;\n      } // Make sure the ref has a child\n\n\n      if (ref && ref.childNodes && ref.childNodes[0] && Number.isInteger(ref.childNodes[0].offsetHeight)) {\n        var height = ref.childNodes[0].offsetHeight; // Add to the total to calculate the averageAutoHeight.\n\n        total += height;\n        totalAmount += 1; // Cache the height.\n\n        autoHeights[index] = height; // Set the update flag to true.\n\n        isUpdated = true;\n      }\n    }); // Save the average height.\n\n    averageAutoHeight = total / totalAmount; // There are some new heights detected that had previously not been calculated.\n    // Call forceUpdate to make sure the virtual list renders again.\n\n    if (isUpdated) forceUpdate();\n  };\n\n  var onVirtualHelperRef = function onVirtualHelperRef(index, ref) {\n    autoHeightRefs[index] = ref;\n    requestAnimationFrame(function () {\n      processAutoHeights();\n    });\n  };\n\n  var getItemSize = function getItemSize(children) {\n    // Prefer to return a array of all heights.\n    if (!allowAutoHeight) {\n      return children.map(function (child) {\n        if (!React.isValidElement(child)) return defaultHeight;\n        var height = child.props.height;\n\n        if (Number.isInteger(height)) {\n          return height;\n        }\n\n        return defaultHeight;\n      });\n    } // If allowAutoHeight is true, return a function instead.\n\n\n    var itemSizeFn = function itemSizeFn(index) {\n      if (!React.isValidElement(children[index])) return defaultHeight;\n      var height = children[index].props.height; // When the height is number simply, simply return it.\n\n      if (Number.isInteger(height)) {\n        return height;\n      } // When allowAutoHeight is set and  the height is set to \"auto\"...\n\n\n      if (allowAutoHeight && children[index].props.height === 'auto') {\n        // ... and the height is calculated, return the calculated height.\n        if (autoHeights[index]) return autoHeights[index]; // ... if the height is not yet calculated, return the averge\n\n        if (useAverageAutoHeightEstimation) return averageAutoHeight;\n      } // Return the default height.\n\n\n      return defaultHeight;\n    };\n\n    return itemSizeFn;\n  }; // Children always needs to be an array.\n\n\n  var children = Array.isArray(inputChildren) ? inputChildren : React.Children.toArray(inputChildren);\n  var itemSize = getItemSize(children);\n  return React.createElement(Pane, _extends({\n    \"data-evergreen-table-body\": true,\n    ref: setPaneRef,\n    height: paneHeight,\n    flex: \"1\",\n    overflow: \"hidden\"\n  }, rest), React.createElement(VirtualList, {\n    height: isIntegerHeight ? paneHeight : calculatedHeight,\n    width: \"100%\",\n    estimatedItemSize: allowAutoHeight && useAverageAutoHeightEstimation ? averageAutoHeight : estimatedItemSize || null,\n    itemSize: itemSize,\n    overscanCount: overscanCount,\n    itemCount: React.Children.count(children),\n    scrollToIndex: scrollToIndex,\n    scrollOffset: scrollOffset,\n    scrollToAlignment: scrollToAlignment,\n    onScroll: onScroll,\n    renderItem: function renderItem(_ref) {\n      var index = _ref.index,\n          style = _ref.style;\n      var child = children[index];\n      var key = child.key || index;\n      var props = {\n        key: key,\n        style: style\n      }; // If some children are strings by accident, support this gracefully.\n\n      if (!React.isValidElement(child)) {\n        if (typeof child === 'string') {\n          return React.createElement(\"div\", props, child);\n        }\n\n        return React.createElement(\"div\", props, \"\\xA0\");\n      } // When allowing height=\"auto\" for rows, and a auto height item is\n      // rendered for the first time...\n\n\n      if (allowAutoHeight && React.isValidElement(child) && child.props.height === 'auto' && // ... and only when the height is not already been calculated.\n      !autoHeights[index]) {\n        // ... render the item in a helper div, the ref is used to calculate\n        // the height of its children.\n        return React.createElement(\"div\", _extends({\n          ref: function ref(_ref2) {\n            return onVirtualHelperRef(index, _ref2);\n          },\n          \"data-virtual-index\": index\n        }, props, {\n          style: _objectSpread({\n            opacity: 0\n          }, props.style)\n        }), child);\n      } // When allowAutoHeight is false, or when the height is known.\n      // Simply render the item.\n\n\n      return React.cloneElement(child, props);\n    }\n  }));\n});\nTableVirtualBody.propTypes = _objectSpread(_objectSpread({}, Pane.propTypes), {}, {\n  /**\n   * Children needs to be an array of a single node.\n   */\n  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),\n\n  /**\n   * Default height of each row.\n   * 48 is the default height of a TableRow.\n   */\n  defaultHeight: PropTypes.number,\n\n  /**\n   * When true, support `height=\"auto\"` on children being rendered.\n   * This is somewhat of an expirmental feature.\n   */\n  allowAutoHeight: PropTypes.bool,\n\n  /**\n   * The overscanCount property passed to react-tiny-virtual-list.\n   */\n  overscanCount: PropTypes.number,\n\n  /**\n   * When passed, this is used as the `estimatedItemSize` in react-tiny-virtual-list.\n   * Only when `allowAutoHeight` and`useAverageAutoHeightEstimation` are false.\n   */\n  estimatedItemSize: PropTypes.number,\n\n  /**\n   * When allowAutoHeight is true and this prop is true, the estimated height\n   * will be computed based on the average height of auto height rows.\n   */\n  useAverageAutoHeightEstimation: PropTypes.bool,\n\n  /**\n   * The scrollToIndex property passed to react-tiny-virtual-list\n   */\n  scrollToIndex: PropTypes.number,\n\n  /**\n   * The scrollOffset property passed to react-tiny-virtual-list\n   */\n  scrollOffset: PropTypes.number,\n\n  /**\n   * The scrollToAlignment property passed to react-tiny-virtual-list\n   */\n  scrollToAlignment: PropTypes.oneOf(['start', 'center', 'end', 'auto']),\n\n  /**\n   * The onScroll callback passed to react-tiny-virtual-list\n   */\n  onScroll: PropTypes.func\n});\nexport default TableVirtualBody;","map":{"version":3,"sources":["../../../src/table/src/TableVirtualBody.js"],"names":["TableVirtualBody","memo","inputChildren","paneHeight","defaultHeight","allowAutoHeight","overscanCount","estimatedItemSize","useAverageAutoHeightEstimation","scrollToIndex","scrollOffset","scrollToAlignment","onScroll","rest","props","forceUpdate","useForceUpdate","autoHeights","autoHeightRefs","averageAutoHeight","paneRef","setPaneRef","useState","isIntegerHeight","setIsIntegerHeight","calculatedHeight","setCalculatedHeight","updateOnResize","tempCalculatedHeight","requestAnimationFrame","onResize","debounce","useEffect","Number","window","processAutoHeights","isUpdated","total","totalAmount","ref","height","onVirtualHelperRef","getItemSize","React","child","itemSizeFn","children","Array","itemSize","index","style","key","opacity","Pane","PropTypes","func"],"mappings":"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","sourcesContent":["import React, { memo, useState, useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport VirtualList from 'react-tiny-virtual-list'\nimport debounce from 'lodash.debounce'\nimport { Pane } from '../../layers'\nimport { useForceUpdate } from '../../hooks'\n\nconst TableVirtualBody = memo(function TableVirtualBody(props) {\n  const {\n    children: inputChildren,\n    height: paneHeight,\n    defaultHeight = 48,\n    allowAutoHeight = false,\n    overscanCount = 5,\n    estimatedItemSize,\n    useAverageAutoHeightEstimation = true,\n    scrollToIndex,\n    scrollOffset,\n    scrollToAlignment,\n    onScroll,\n    ...rest\n  } = props\n\n  const forceUpdate = useForceUpdate()\n  let autoHeights = []\n  let autoHeightRefs = []\n  let averageAutoHeight = defaultHeight\n\n  const [paneRef, setPaneRef] = useState()\n  const [isIntegerHeight, setIsIntegerHeight] = useState(false)\n  const [calculatedHeight, setCalculatedHeight] = useState(0)\n\n  const updateOnResize = () => {\n    autoHeights = []\n    autoHeightRefs = []\n    averageAutoHeight = defaultHeight\n\n    // Simply return when we now the height of the pane is fixed.\n    if (isIntegerHeight) return\n\n    // Return if we are in a weird edge case in which the ref is no longer valid.\n    if (paneRef && paneRef instanceof Node) {\n      const tempCalculatedHeight = paneRef.offsetHeight\n\n      if (tempCalculatedHeight > 0) {\n        // Save the calculated height which is needed for the VirtualList.\n        setCalculatedHeight(tempCalculatedHeight)\n\n        // Prevent updateOnResize being called recursively when there is a valid height.\n        return\n      }\n    }\n\n    // When height is still 0 (or paneRef is not valid) try recursively until success.\n    requestAnimationFrame(() => {\n      updateOnResize()\n    })\n  }\n\n  const onResize = debounce(updateOnResize, 200)\n\n  useEffect(() => {\n    if (props.height !== calculatedHeight) {\n      setIsIntegerHeight(Number.isInteger(props.height))\n    }\n  }, [props.height])\n\n  useEffect(() => {\n    if (paneRef && paneRef instanceof Node) {\n      updateOnResize()\n    }\n  }, [paneRef])\n\n  // Mirrors functionality of componentDidMount and componentWillUnmount.\n  // By passing an empty array, will only run on first render, the function returned\n  // will be called on component unmount\n  useEffect(() => {\n    updateOnResize()\n    window.addEventListener('resize', onResize, false)\n\n    return () => {\n      window.removeEventListener('resize', onResize)\n    }\n  }, [])\n\n  /**\n   * This function will process all items that have height=\"auto\" set.\n   * It will loop through all refs and get calculate the height.\n   */\n  const processAutoHeights = () => {\n    let isUpdated = false\n\n    // This will determine the averageAutoHeight.\n    let total = 0\n    let totalAmount = 0\n\n    // Loop through all of the refs that have height=\"auto\".\n    autoHeightRefs.forEach((ref, index) => {\n      // If the height is already calculated, skip it,\n      // but calculate the height for the total.\n      if (autoHeights[index]) {\n        total += autoHeights[index]\n        totalAmount += 1\n        return\n      }\n\n      // Make sure the ref has a child\n      if (\n        ref &&\n        ref.childNodes &&\n        ref.childNodes[0] &&\n        Number.isInteger(ref.childNodes[0].offsetHeight)\n      ) {\n        const height = ref.childNodes[0].offsetHeight\n\n        // Add to the total to calculate the averageAutoHeight.\n        total += height\n        totalAmount += 1\n\n        // Cache the height.\n        autoHeights[index] = height\n\n        // Set the update flag to true.\n        isUpdated = true\n      }\n    })\n\n    // Save the average height.\n    averageAutoHeight = total / totalAmount\n\n    // There are some new heights detected that had previously not been calculated.\n    // Call forceUpdate to make sure the virtual list renders again.\n    if (isUpdated) forceUpdate()\n  }\n\n  const onVirtualHelperRef = (index, ref) => {\n    autoHeightRefs[index] = ref\n\n    requestAnimationFrame(() => {\n      processAutoHeights()\n    })\n  }\n\n  const getItemSize = children => {\n    // Prefer to return a array of all heights.\n    if (!allowAutoHeight) {\n      return children.map(child => {\n        if (!React.isValidElement(child)) return defaultHeight\n        const { height } = child.props\n\n        if (Number.isInteger(height)) {\n          return height\n        }\n\n        return defaultHeight\n      })\n    }\n\n    // If allowAutoHeight is true, return a function instead.\n    const itemSizeFn = index => {\n      if (!React.isValidElement(children[index])) return defaultHeight\n      const { height } = children[index].props\n\n      // When the height is number simply, simply return it.\n      if (Number.isInteger(height)) {\n        return height\n      }\n\n      // When allowAutoHeight is set and  the height is set to \"auto\"...\n      if (allowAutoHeight && children[index].props.height === 'auto') {\n        // ... and the height is calculated, return the calculated height.\n        if (autoHeights[index]) return autoHeights[index]\n\n        // ... if the height is not yet calculated, return the averge\n        if (useAverageAutoHeightEstimation) return averageAutoHeight\n      }\n\n      // Return the default height.\n      return defaultHeight\n    }\n\n    return itemSizeFn\n  }\n\n  // Children always needs to be an array.\n  const children = Array.isArray(inputChildren)\n    ? inputChildren\n    : React.Children.toArray(inputChildren)\n\n  const itemSize = getItemSize(children)\n\n  return (\n    <Pane\n      data-evergreen-table-body\n      ref={setPaneRef}\n      height={paneHeight}\n      flex=\"1\"\n      overflow=\"hidden\"\n      {...rest}\n    >\n      <VirtualList\n        height={isIntegerHeight ? paneHeight : calculatedHeight}\n        width=\"100%\"\n        estimatedItemSize={\n          allowAutoHeight && useAverageAutoHeightEstimation\n            ? averageAutoHeight\n            : estimatedItemSize || null\n        }\n        itemSize={itemSize}\n        overscanCount={overscanCount}\n        itemCount={React.Children.count(children)}\n        scrollToIndex={scrollToIndex}\n        scrollOffset={scrollOffset}\n        scrollToAlignment={scrollToAlignment}\n        onScroll={onScroll}\n        renderItem={({ index, style }) => {\n          const child = children[index]\n          const key = child.key || index\n          const props = {\n            key,\n            style\n          }\n\n          // If some children are strings by accident, support this gracefully.\n          if (!React.isValidElement(child)) {\n            if (typeof child === 'string') {\n              return <div {...props}>{child}</div>\n            }\n\n            return <div {...props}>&nbsp;</div>\n          }\n\n          // When allowing height=\"auto\" for rows, and a auto height item is\n          // rendered for the first time...\n          if (\n            allowAutoHeight &&\n            React.isValidElement(child) &&\n            child.props.height === 'auto' &&\n            // ... and only when the height is not already been calculated.\n            !autoHeights[index]\n          ) {\n            // ... render the item in a helper div, the ref is used to calculate\n            // the height of its children.\n            return (\n              <div\n                ref={ref => onVirtualHelperRef(index, ref)}\n                data-virtual-index={index}\n                {...props}\n                style={{\n                  opacity: 0,\n                  ...props.style\n                }}\n              >\n                {child}\n              </div>\n            )\n          }\n\n          // When allowAutoHeight is false, or when the height is known.\n          // Simply render the item.\n          return React.cloneElement(child, props)\n        }}\n      />\n    </Pane>\n  )\n})\n\nTableVirtualBody.propTypes = {\n  /**\n   * Composes the Pane component as the base.\n   */\n  ...Pane.propTypes,\n\n  /**\n   * Children needs to be an array of a single node.\n   */\n  children: PropTypes.oneOfType([\n    PropTypes.arrayOf(PropTypes.node),\n    PropTypes.node\n  ]),\n\n  /**\n   * Default height of each row.\n   * 48 is the default height of a TableRow.\n   */\n  defaultHeight: PropTypes.number,\n\n  /**\n   * When true, support `height=\"auto\"` on children being rendered.\n   * This is somewhat of an expirmental feature.\n   */\n  allowAutoHeight: PropTypes.bool,\n\n  /**\n   * The overscanCount property passed to react-tiny-virtual-list.\n   */\n  overscanCount: PropTypes.number,\n\n  /**\n   * When passed, this is used as the `estimatedItemSize` in react-tiny-virtual-list.\n   * Only when `allowAutoHeight` and`useAverageAutoHeightEstimation` are false.\n   */\n  estimatedItemSize: PropTypes.number,\n\n  /**\n   * When allowAutoHeight is true and this prop is true, the estimated height\n   * will be computed based on the average height of auto height rows.\n   */\n  useAverageAutoHeightEstimation: PropTypes.bool,\n\n  /**\n   * The scrollToIndex property passed to react-tiny-virtual-list\n   */\n  scrollToIndex: PropTypes.number,\n  /**\n   * The scrollOffset property passed to react-tiny-virtual-list\n   */\n  scrollOffset: PropTypes.number,\n  /**\n   * The scrollToAlignment property passed to react-tiny-virtual-list\n   */\n  scrollToAlignment: PropTypes.oneOf(['start', 'center', 'end', 'auto']),\n  /**\n   * The onScroll callback passed to react-tiny-virtual-list\n   */\n  onScroll: PropTypes.func\n}\n\nexport default TableVirtualBody\n"]},"metadata":{},"sourceType":"module"}