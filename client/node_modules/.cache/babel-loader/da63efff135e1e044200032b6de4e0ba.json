{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { css } from 'glamor';\nimport React, { memo, forwardRef, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { Text } from '../../typography';\nimport { IconWrapper } from '../../icons/src/IconWrapper';\nimport { SearchIcon } from '../../icons';\nimport TableHeaderCell from './TableHeaderCell';\nvar invisibleInputClass = css({\n  border: 'none',\n  backgroundColor: 'transparent',\n  WebkitAppearance: 'none',\n  MozAppearance: 'none',\n  WebkitFontSmoothing: 'antialiased',\n  '&:focus': {\n    outline: 'none'\n  },\n  '&::placeholder': {\n    color: \"rgba(67, 90, 111, 0.7)\"\n  }\n}).toString();\n\nvar noop = function noop() {};\n\nvar SearchTableHeaderCell = memo(forwardRef(function SearchTableHeaderCell(props, ref) {\n  var value = props.value,\n      children = props.children,\n      _props$onChange = props.onChange,\n      onChange = _props$onChange === void 0 ? noop : _props$onChange,\n      autoFocus = props.autoFocus,\n      _props$spellCheck = props.spellCheck,\n      spellCheck = _props$spellCheck === void 0 ? true : _props$spellCheck,\n      _props$placeholder = props.placeholder,\n      placeholder = _props$placeholder === void 0 ? 'Filter...' : _props$placeholder,\n      _props$icon = props.icon,\n      icon = _props$icon === void 0 ? SearchIcon : _props$icon,\n      rest = _objectWithoutProperties(props, [\"value\", \"children\", \"onChange\", \"autoFocus\", \"spellCheck\", \"placeholder\", \"icon\"]);\n\n  var handleChange = useCallback(function (e) {\n    return onChange(e.target.value);\n  }, [onChange]);\n  return React.createElement(TableHeaderCell, rest, React.createElement(IconWrapper, {\n    icon: icon,\n    color: \"muted\",\n    marginLeft: 2,\n    marginRight: 10,\n    size: 12\n  }), React.createElement(Text, {\n    is: \"input\",\n    size: 300,\n    flex: \"1\",\n    className: invisibleInputClass,\n    value: value,\n    onChange: handleChange,\n    autoFocus: autoFocus,\n    spellCheck: spellCheck,\n    fontWeight: 500,\n    marginLeft: -2,\n    paddingLeft: 0,\n    placeholder: placeholder,\n    ref: ref\n  }));\n}));\nSearchTableHeaderCell.propTypes = _objectSpread(_objectSpread({}, TableHeaderCell.propTypes), {}, {\n  /**\n   * The value of the input.\n   */\n  value: PropTypes.string,\n\n  /**\n   * Handler to be called when the input changes.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * Sets whether the component should be automatically focused on component render.\n   */\n  autoFocus: PropTypes.bool,\n\n  /**\n   * Sets whether to apply spell checking to the content.\n   */\n  spellCheck: PropTypes.bool,\n\n  /**\n   * Text to display in the input if the input is empty.\n   */\n  placeholder: PropTypes.string,\n\n  /**\n   * The Evergreen or custom icon before the label.\n   */\n  icon: PropTypes.oneOfType([PropTypes.elementType, PropTypes.element])\n});\nexport default SearchTableHeaderCell;","map":{"version":3,"sources":["../../../src/table/src/SearchTableHeaderCell.js"],"names":["invisibleInputClass","border","backgroundColor","WebkitAppearance","MozAppearance","WebkitFontSmoothing","outline","color","noop","SearchTableHeaderCell","memo","forwardRef","value","children","onChange","autoFocus","spellCheck","placeholder","icon","rest","props","handleChange","useCallback","e","ref","TableHeaderCell","PropTypes"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,GAAA,QAAA,QAAA;AACA,OAAA,KAAA,IAAA,IAAA,EAAA,UAAA,EAAA,WAAA,QAAA,OAAA;AACA,OAAA,SAAA,MAAA,YAAA;AACA,SAAA,IAAA,QAAA,kBAAA;AACA,SAAA,WAAA,QAAA,6BAAA;AACA,SAAA,UAAA,QAAA,aAAA;AACA,OAAA,eAAA,MAAA,mBAAA;AAEA,IAAMA,mBAAmB,GAAG,GAAG,CAAC;AAC9BC,EAAAA,MAAM,EADwB,MAAA;AAE9BC,EAAAA,eAAe,EAFe,aAAA;AAG9BC,EAAAA,gBAAgB,EAHc,MAAA;AAI9BC,EAAAA,aAAa,EAJiB,MAAA;AAK9BC,EAAAA,mBAAmB,EALW,aAAA;AAO9B,aAAW;AACTC,IAAAA,OAAO,EAAE;AADA,GAPmB;AAW9B,oBAAkB;AAChBC,IAAAA,KAAK,EAAA;AADW;AAXY,CAAD,CAAH,CAA5B,QAA4B,EAA5B;;AAgBA,IAAMC,IAAI,GAAG,SAAPA,IAAO,GAAM,CAAnB,CAAA;;AAEA,IAAMC,qBAAqB,GAAGC,IAAI,CAChCC,UAAU,CAAC,SAAA,qBAAA,CAAA,KAAA,EAAA,GAAA,EAA2C;AAAA,MAElDC,KAFkD,GAUhDQ,KAVgD,CAAA,KAAA;AAAA,MAGlDP,QAHkD,GAUhDO,KAVgD,CAAA,QAAA;AAAA,MAAA,eAAA,GAUhDA,KAVgD,CAAA,QAAA;AAAA,MAIlDN,QAJkD,GAAA,eAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,eAAA;AAAA,MAKlDC,SALkD,GAUhDK,KAVgD,CAAA,SAAA;AAAA,MAAA,iBAAA,GAUhDA,KAVgD,CAAA,UAAA;AAAA,MAMlDJ,UANkD,GAAA,iBAAA,KAAA,KAAA,CAAA,GAAA,IAAA,GAAA,iBAAA;AAAA,MAAA,kBAAA,GAUhDI,KAVgD,CAAA,WAAA;AAAA,MAOlDH,WAPkD,GAAA,kBAAA,KAAA,KAAA,CAAA,GAAA,WAAA,GAAA,kBAAA;AAAA,MAAA,WAAA,GAUhDG,KAVgD,CAAA,IAAA;AAAA,MAQlDF,IARkD,GAAA,WAAA,KAAA,KAAA,CAAA,GAAA,UAAA,GAAA,WAAA;AAAA,MAS/CC,IAT+C,GAAA,wBAAA,CAAA,KAAA,EAAA,CAAA,OAAA,EAAA,UAAA,EAAA,UAAA,EAAA,WAAA,EAAA,YAAA,EAAA,aAAA,EAAA,MAAA,CAAA,CAAA;;AAYpD,MAAME,YAAY,GAAGC,WAAW,CAAC,UAAA,CAAA,EAAC;AAAA,WAAIR,QAAQ,CAACS,CAAC,CAADA,MAAAA,CAAb,KAAY,CAAZ;AAAF,GAAA,EAAgC,CAAhE,QAAgE,CAAhC,CAAhC;AAEA,SACE,KAAA,CAAA,aAAA,CAAA,eAAA,EAAA,IAAA,EACE,KAAA,CAAA,aAAA,CAAA,WAAA,EAAA;AACE,IAAA,IAAI,EADN,IAAA;AAEE,IAAA,KAAK,EAFP,OAAA;AAGE,IAAA,UAAU,EAHZ,CAAA;AAIE,IAAA,WAAW,EAJb,EAAA;AAKE,IAAA,IAAI,EAAE;AALR,GAAA,CADF,EAQE,KAAA,CAAA,aAAA,CAAA,IAAA,EAAA;AACE,IAAA,EAAE,EADJ,OAAA;AAEE,IAAA,IAAI,EAFN,GAAA;AAGE,IAAA,IAAI,EAHN,GAAA;AAIE,IAAA,SAAS,EAJX,mBAAA;AAKE,IAAA,KAAK,EALP,KAAA;AAME,IAAA,QAAQ,EANV,YAAA;AAOE,IAAA,SAAS,EAPX,SAAA;AAQE,IAAA,UAAU,EARZ,UAAA;AASE,IAAA,UAAU,EATZ,GAAA;AAUE,IAAA,UAAU,EAAE,CAVd,CAAA;AAWE,IAAA,WAAW,EAXb,CAAA;AAYE,IAAA,WAAW,EAZb,WAAA;AAaE,IAAA,GAAG,EAAEC;AAbP,GAAA,CARF,CADF;AAfJ,CACY,CADsB,CAAlC;AA4CAf,qBAAqB,CAArBA,SAAAA,GAAAA,aAAAA,CAAAA,aAAAA,CAAAA,EAAAA,EAIKgB,eAAe,CAJpBhB,SAAAA,CAAAA,EAAAA,EAAAA,EAAAA;AAME;;;AAGAG,EAAAA,KAAK,EAAEc,SAAS,CATlBjB,MAAAA;;AAWE;;;AAGAK,EAAAA,QAAQ,EAAEY,SAAS,CAdrBjB,IAAAA;;AAgBE;;;AAGAM,EAAAA,SAAS,EAAEW,SAAS,CAnBtBjB,IAAAA;;AAqBE;;;AAGAO,EAAAA,UAAU,EAAEU,SAAS,CAxBvBjB,IAAAA;;AA0BE;;;AAGAQ,EAAAA,WAAW,EAAES,SAAS,CA7BxBjB,MAAAA;;AA+BE;;;AAGAS,EAAAA,IAAI,EAAEQ,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAAV,WAAA,EAAwBA,SAAS,CAArDA,OAAoB,CAApBA;AAlCRjB,CAAAA,CAAAA;AAqCA,eAAA,qBAAA","sourcesContent":["import { css } from 'glamor'\nimport React, { memo, forwardRef, useCallback } from 'react'\nimport PropTypes from 'prop-types'\nimport { Text } from '../../typography'\nimport { IconWrapper } from '../../icons/src/IconWrapper'\nimport { SearchIcon } from '../../icons'\nimport TableHeaderCell from './TableHeaderCell'\n\nconst invisibleInputClass = css({\n  border: 'none',\n  backgroundColor: 'transparent',\n  WebkitAppearance: 'none',\n  MozAppearance: 'none',\n  WebkitFontSmoothing: 'antialiased',\n\n  '&:focus': {\n    outline: 'none'\n  },\n\n  '&::placeholder': {\n    color: `rgba(67, 90, 111, 0.7)`\n  }\n}).toString()\n\nconst noop = () => {}\n\nconst SearchTableHeaderCell = memo(\n  forwardRef(function SearchTableHeaderCell(props, ref) {\n    const {\n      value,\n      children,\n      onChange = noop,\n      autoFocus,\n      spellCheck = true,\n      placeholder = 'Filter...',\n      icon = SearchIcon,\n      ...rest\n    } = props\n\n    const handleChange = useCallback(e => onChange(e.target.value), [onChange])\n\n    return (\n      <TableHeaderCell {...rest}>\n        <IconWrapper\n          icon={icon}\n          color=\"muted\"\n          marginLeft={2}\n          marginRight={10}\n          size={12}\n        />\n        <Text\n          is=\"input\"\n          size={300}\n          flex=\"1\"\n          className={invisibleInputClass}\n          value={value}\n          onChange={handleChange}\n          autoFocus={autoFocus}\n          spellCheck={spellCheck}\n          fontWeight={500}\n          marginLeft={-2}\n          paddingLeft={0}\n          placeholder={placeholder}\n          ref={ref}\n        />\n      </TableHeaderCell>\n    )\n  })\n)\n\nSearchTableHeaderCell.propTypes = {\n  /**\n   * Composes the TableHeaderCell component as the base.\n   */\n  ...TableHeaderCell.propTypes,\n\n  /**\n   * The value of the input.\n   */\n  value: PropTypes.string,\n\n  /**\n   * Handler to be called when the input changes.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * Sets whether the component should be automatically focused on component render.\n   */\n  autoFocus: PropTypes.bool,\n\n  /**\n   * Sets whether to apply spell checking to the content.\n   */\n  spellCheck: PropTypes.bool,\n\n  /**\n   * Text to display in the input if the input is empty.\n   */\n  placeholder: PropTypes.string,\n\n  /**\n   * The Evergreen or custom icon before the label.\n   */\n  icon: PropTypes.oneOfType([PropTypes.elementType, PropTypes.element])\n}\n\nexport default SearchTableHeaderCell\n"]},"metadata":{},"sourceType":"module"}