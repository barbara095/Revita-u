{"ast":null,"code":"import { css } from 'glamor';\n/**\n * Memoize a function that takes N number of strings as arguments and returns\n * a CSS-in-JS object.\n *\n * The key of the cache will be the concatenated string arguments,\n * For example: `primary_success` or `regular`\n *\n * The CSS-in-JS object will be passed to `glamor` and the generated className\n * will be used as the value in the cache.\n *\n * Why?\n * Glamor, or any CSS-in-JS solution wil have a build-in cache.\n * However, to get the hash/key of this build-in cache a relatively expensive\n * hashing function needs to run on the CSS-in-JS object.\n * This function removes the need for the build-in cache and acts as much\n * faster alternative.\n *\n * @param {function} fn — function that return an appearance (object).\n * @return {string} a class name.\n */\n\nvar memoizeClassName = function memoizeClassName(fn) {\n  // Memo will hold a list of string keys with string values (classNames).\n  var memo = {}; // Return the wrapped function.\n\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    } // Create a key by joining all args.\n\n\n    var key = args.join('_') || '__no_args__'; // Check if is already memoized, if so return the result.\n\n    if (memo[key]) return memo[key]; // Create a new entry in the memo with the generated className.\n\n    memo[key] = css(fn.apply(void 0, args)).toString(); // Return the newly generated className.\n\n    return memo[key];\n  };\n};\n\nexport default memoizeClassName;","map":{"version":3,"sources":["../../../../../src/theme/src/default-theme/utils/memoizeClassName.js"],"names":["memoizeClassName","memo","args","key","css","fn"],"mappings":"AAAA,SAAA,GAAA,QAAA,QAAA;AAEA;;;;;;;;;;;;;;;;;;;;;AAoBA,IAAMA,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAA,EAAA,EAAM;AAC7B;AACA,MAAMC,IAAI,GAFmB,EAE7B,CAF6B,CAI7B;;AACA,SAAO,YAAa;AAAA,SAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EAATC,IAAS,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;AAATA,MAAAA,IAAS,CAAA,IAAA,CAATA,GAAS,SAAA,CAAA,IAAA,CAATA;AAAS,KAAA,CAClB;;;AACA,QAAMC,GAAG,GAAGD,IAAI,CAAJA,IAAAA,CAAAA,GAAAA,KAFM,aAElB,CAFkB,CAIlB;;AACA,QAAID,IAAI,CAAR,GAAQ,CAAR,EAAe,OAAOA,IAAI,CALR,GAKQ,CAAX,CALG,CAOlB;;AACAA,IAAAA,IAAI,CAAJA,GAAI,CAAJA,GAAYG,GAAG,CAACC,EAAE,CAAFA,KAAAA,CAAAA,KAAAA,CAAAA,EAAJD,IAAIC,CAAD,CAAHD,CARM,QAQNA,EAAZH,CARkB,CAUlB;;AACA,WAAOA,IAAI,CAAX,GAAW,CAAX;AAXF,GAAA;AALF,CAAA;;AAoBA,eAAA,gBAAA","sourcesContent":["import { css } from 'glamor'\n\n/**\n * Memoize a function that takes N number of strings as arguments and returns\n * a CSS-in-JS object.\n *\n * The key of the cache will be the concatenated string arguments,\n * For example: `primary_success` or `regular`\n *\n * The CSS-in-JS object will be passed to `glamor` and the generated className\n * will be used as the value in the cache.\n *\n * Why?\n * Glamor, or any CSS-in-JS solution wil have a build-in cache.\n * However, to get the hash/key of this build-in cache a relatively expensive\n * hashing function needs to run on the CSS-in-JS object.\n * This function removes the need for the build-in cache and acts as much\n * faster alternative.\n *\n * @param {function} fn — function that return an appearance (object).\n * @return {string} a class name.\n */\nconst memoizeClassName = fn => {\n  // Memo will hold a list of string keys with string values (classNames).\n  const memo = {}\n\n  // Return the wrapped function.\n  return (...args) => {\n    // Create a key by joining all args.\n    const key = args.join('_') || '__no_args__'\n\n    // Check if is already memoized, if so return the result.\n    if (memo[key]) return memo[key]\n\n    // Create a new entry in the memo with the generated className.\n    memo[key] = css(fn(...args)).toString()\n\n    // Return the newly generated className.\n    return memo[key]\n  }\n}\n\nexport default memoizeClassName\n"]},"metadata":{},"sourceType":"module"}