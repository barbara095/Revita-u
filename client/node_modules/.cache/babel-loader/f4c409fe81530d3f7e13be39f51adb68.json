{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { memo, useRef, useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { Textarea } from '../../textarea';\nvar EditableCellField = memo(function EditableCellField(props) {\n  var getTargetRef = props.getTargetRef;\n\n  var getTableBodyRef = function getTableBodyRef() {\n    var ref = getTargetRef();\n    if (!ref) return;\n\n    while (ref) {\n      var isTableBody = ref.hasAttribute('data-evergreen-table-body');\n\n      if (isTableBody) {\n        return ref;\n      }\n\n      if (ref.parentElement) {\n        ref = ref.parentElement;\n      } else {\n        return null;\n      }\n    }\n\n    return ref;\n  };\n\n  var latestAnimationFrame = useRef();\n  var textareaRef = useRef();\n  var tableBodyRef = useRef();\n\n  var _useState = useState({\n    top: 0,\n    left: 0,\n    height: 0,\n    width: 0\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      _useState2$ = _useState2[0],\n      height = _useState2$.height,\n      width = _useState2$.width,\n      top = _useState2$.top,\n      left = _useState2$.left,\n      setDimensions = _useState2[1]; // Mirrors functionality of componentDidMount and componentWillUnmount.\n  // Focus on mount\n\n\n  useEffect(function () {\n    update();\n    var requestId = requestAnimationFrame(function () {\n      if (textareaRef.current) {\n        textareaRef.current.focus();\n      }\n    });\n    return function () {\n      cancelAnimationFrame(requestId);\n\n      if (latestAnimationFrame.current) {\n        cancelAnimationFrame(latestAnimationFrame.current);\n      }\n\n      props.onCancel();\n    };\n  }, []);\n\n  var update = function update() {\n    var getTargetRef = props.getTargetRef;\n    var targetRef = getTargetRef();\n    if (!targetRef) return;\n    tableBodyRef.current = getTableBodyRef();\n\n    var _targetRef$getBoundin = targetRef.getBoundingClientRect(),\n        targetLeft = _targetRef$getBoundin.left,\n        targetTop = _targetRef$getBoundin.top,\n        targetHeight = _targetRef$getBoundin.height,\n        targetWidth = _targetRef$getBoundin.width;\n\n    var calculatedTop;\n\n    if (tableBodyRef.current) {\n      var bounds = tableBodyRef.current.getBoundingClientRect();\n      calculatedTop = Math.min(Math.max(targetTop, bounds.top), bounds.bottom - targetHeight);\n    } else {\n      calculatedTop = targetTop;\n    }\n\n    setDimensions({\n      top: calculatedTop,\n      left: targetLeft,\n      height: targetHeight,\n      width: targetWidth\n    });\n    latestAnimationFrame.current = requestAnimationFrame(function () {\n      return update();\n    });\n  };\n\n  var handleFocus = function handleFocus(e) {\n    e.target.selectionStart = e.target.value.length;\n  };\n\n  var handleBlur = function handleBlur() {\n    if (textareaRef.current) props.onChangeComplete(textareaRef.current.value);\n  };\n\n  var handleKeyDown = function handleKeyDown(e) {\n    switch (e.key) {\n      case 'Escape':\n        props.onCancel();\n        if (textareaRef.current) textareaRef.current.blur();\n        break;\n\n      case 'Enter':\n        if (textareaRef.current) textareaRef.current.blur();\n        e.preventDefault();\n        break;\n\n      case 'Tab':\n        if (textareaRef.current) textareaRef.current.blur();\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  var size = props.size,\n      value = props.value,\n      _props$minWidth = props.minWidth,\n      minWidth = _props$minWidth === void 0 ? 80 : _props$minWidth,\n      _props$minHeight = props.minHeight,\n      minHeight = _props$minHeight === void 0 ? 40 : _props$minHeight,\n      zIndex = props.zIndex;\n  return React.createElement(Textarea, {\n    ref: textareaRef,\n    onKeyDown: handleKeyDown,\n    onBlur: handleBlur,\n    onFocus: handleFocus,\n    appearance: \"editable-cell\",\n    size: size,\n    style: {\n      left: left,\n      top: top,\n      height: height,\n      minHeight: Math.max(height, minHeight),\n      width: width,\n      minWidth: Math.max(width, minWidth),\n      zIndex: zIndex\n    },\n    height: null,\n    width: null,\n    minHeight: null,\n    position: \"fixed\",\n    defaultValue: value\n  });\n});\nEditableCellField.propTypes = {\n  /**\n   * Used as the defaultValue of the textarea.\n   */\n  value: PropTypes.string.isRequired,\n\n  /**\n   * The z-index placed on the element.\n   */\n  zIndex: PropTypes.number.isRequired,\n\n  /**\n   * Function to get the target ref of the parent.\n   * Used to mirror the position.\n   */\n  getTargetRef: PropTypes.func.isRequired,\n\n  /**\n   * Min width of the textarea.\n   * The textarea can never be smaller than the cell.\n   */\n  minWidth: PropTypes.number,\n\n  /**\n   * Min height of the textarea.\n   * The textarea can never be smaller than the cell.\n   */\n  minHeight: PropTypes.number,\n\n  /**\n   * Called when the textarea is blurred, pass the value back to the cell.\n   */\n  onChangeComplete: PropTypes.func.isRequired,\n\n  /**\n   * Called when Escape is hit or componentWillUnmount.\n   */\n  onCancel: PropTypes.func.isRequired,\n\n  /**\n   * Text size of the textarea.\n   */\n  size: PropTypes.number\n};\nexport default EditableCellField;","map":{"version":3,"sources":["../../../src/table/src/EditableCellField.js"],"names":["EditableCellField","memo","getTargetRef","props","getTableBodyRef","ref","isTableBody","latestAnimationFrame","useRef","textareaRef","tableBodyRef","height","width","top","left","setDimensions","useState","useEffect","update","requestId","requestAnimationFrame","cancelAnimationFrame","targetRef","targetLeft","targetTop","targetHeight","targetWidth","bounds","calculatedTop","Math","handleFocus","e","handleBlur","handleKeyDown","size","value","minWidth","minHeight","zIndex","PropTypes","onChangeComplete","onCancel","number"],"mappings":"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","sourcesContent":["import React, { memo, useRef, useState, useEffect } from 'react'\nimport PropTypes from 'prop-types'\nimport { Textarea } from '../../textarea'\n\nconst EditableCellField = memo(function EditableCellField(props) {\n  const { getTargetRef } = props\n\n  const getTableBodyRef = () => {\n    let ref = getTargetRef()\n\n    if (!ref) return\n\n    while (ref) {\n      const isTableBody = ref.hasAttribute('data-evergreen-table-body')\n      if (isTableBody) {\n        return ref\n      }\n\n      if (ref.parentElement) {\n        ref = ref.parentElement\n      } else {\n        return null\n      }\n    }\n\n    return ref\n  }\n\n  const latestAnimationFrame = useRef()\n  const textareaRef = useRef()\n  const tableBodyRef = useRef()\n  const [{ height, width, top, left }, setDimensions] = useState({\n    top: 0,\n    left: 0,\n    height: 0,\n    width: 0\n  })\n\n  // Mirrors functionality of componentDidMount and componentWillUnmount.\n  // Focus on mount\n  useEffect(() => {\n    update()\n\n    const requestId = requestAnimationFrame(() => {\n      if (textareaRef.current) {\n        textareaRef.current.focus()\n      }\n    })\n\n    return () => {\n      cancelAnimationFrame(requestId)\n\n      if (latestAnimationFrame.current) {\n        cancelAnimationFrame(latestAnimationFrame.current)\n      }\n\n      props.onCancel()\n    }\n  }, [])\n\n  const update = () => {\n    const { getTargetRef } = props\n    const targetRef = getTargetRef()\n    if (!targetRef) return\n    tableBodyRef.current = getTableBodyRef()\n\n    const {\n      left: targetLeft,\n      top: targetTop,\n      height: targetHeight,\n      width: targetWidth\n    } = targetRef.getBoundingClientRect()\n\n    let calculatedTop\n    if (tableBodyRef.current) {\n      const bounds = tableBodyRef.current.getBoundingClientRect()\n      calculatedTop = Math.min(\n        Math.max(targetTop, bounds.top),\n        bounds.bottom - targetHeight\n      )\n    } else {\n      calculatedTop = targetTop\n    }\n\n    setDimensions({\n      top: calculatedTop,\n      left: targetLeft,\n      height: targetHeight,\n      width: targetWidth\n    })\n    latestAnimationFrame.current = requestAnimationFrame(() => update())\n  }\n\n  const handleFocus = e => {\n    e.target.selectionStart = e.target.value.length\n  }\n\n  const handleBlur = () => {\n    if (textareaRef.current) props.onChangeComplete(textareaRef.current.value)\n  }\n\n  const handleKeyDown = e => {\n    switch (e.key) {\n      case 'Escape':\n        props.onCancel()\n        if (textareaRef.current) textareaRef.current.blur()\n        break\n      case 'Enter':\n        if (textareaRef.current) textareaRef.current.blur()\n        e.preventDefault()\n        break\n      case 'Tab':\n        if (textareaRef.current) textareaRef.current.blur()\n        break\n      default:\n        break\n    }\n  }\n\n  const { size, value, minWidth = 80, minHeight = 40, zIndex } = props\n\n  return (\n    <Textarea\n      ref={textareaRef}\n      onKeyDown={handleKeyDown}\n      onBlur={handleBlur}\n      onFocus={handleFocus}\n      appearance=\"editable-cell\"\n      size={size}\n      style={{\n        left,\n        top,\n        height,\n        minHeight: Math.max(height, minHeight),\n        width,\n        minWidth: Math.max(width, minWidth),\n        zIndex\n      }}\n      height={null}\n      width={null}\n      minHeight={null}\n      position=\"fixed\"\n      defaultValue={value}\n    />\n  )\n})\n\nEditableCellField.propTypes = {\n  /**\n   * Used as the defaultValue of the textarea.\n   */\n  value: PropTypes.string.isRequired,\n\n  /**\n   * The z-index placed on the element.\n   */\n  zIndex: PropTypes.number.isRequired,\n\n  /**\n   * Function to get the target ref of the parent.\n   * Used to mirror the position.\n   */\n  getTargetRef: PropTypes.func.isRequired,\n\n  /**\n   * Min width of the textarea.\n   * The textarea can never be smaller than the cell.\n   */\n  minWidth: PropTypes.number,\n\n  /**\n   * Min height of the textarea.\n   * The textarea can never be smaller than the cell.\n   */\n  minHeight: PropTypes.number,\n\n  /**\n   * Called when the textarea is blurred, pass the value back to the cell.\n   */\n  onChangeComplete: PropTypes.func.isRequired,\n\n  /**\n   * Called when Escape is hit or componentWillUnmount.\n   */\n  onCancel: PropTypes.func.isRequired,\n\n  /**\n   * Text size of the textarea.\n   */\n  size: PropTypes.number\n}\n\nexport default EditableCellField\n"]},"metadata":{},"sourceType":"module"}