{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport React, { memo, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { Portal } from '../../portal';\nimport { Stack } from '../../stack';\nimport safeInvoke from '../../lib/safe-invoke';\nimport TextTableCell from './TextTableCell';\nimport TableCell from './TableCell';\nimport EditableCellField from './EditableCellField';\nvar emptyProps = {};\nvar EditableCell = memo(function EditableCell(props) {\n  var children = props.children,\n      _props$size = props.size,\n      size = _props$size === void 0 ? 300 : _props$size,\n      disabled = props.disabled,\n      placeholder = props.placeholder,\n      _props$isSelectable = props.isSelectable,\n      isSelectable = _props$isSelectable === void 0 ? true : _props$isSelectable,\n      _props$textProps = props.textProps,\n      textProps = _props$textProps === void 0 ? emptyProps : _props$textProps,\n      _props$autoFocus = props.autoFocus,\n      autoFocus = _props$autoFocus === void 0 ? false : _props$autoFocus,\n      rest = _objectWithoutProperties(props, [\"children\", \"size\", \"disabled\", \"placeholder\", \"isSelectable\", \"textProps\", \"autoFocus\"]);\n\n  var cursor = 'text';\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      mainRef = _useState2[0],\n      setMainRef = _useState2[1];\n\n  var _useState3 = useState(children),\n      _useState4 = _slicedToArray(_useState3, 2),\n      value = _useState4[0],\n      setValue = _useState4[1];\n\n  var _useState5 = useState(autoFocus),\n      _useState6 = _slicedToArray(_useState5, 2),\n      isEditing = _useState6[0],\n      setIsEditing = _useState6[1];\n\n  var handleDoubleClick = function handleDoubleClick() {\n    if (disabled || !isSelectable) return;\n    setIsEditing(true);\n  };\n\n  var handleKeyDown = function handleKeyDown(e) {\n    if (disabled) return;\n    var key = e.key;\n    /**\n     * When the user presses a character on the keyboard, use that character\n     * as the value in the text field.\n     */\n\n    if (key === 'Enter' || key === 'Shift') {\n      setIsEditing(true);\n    } else if (key.match(/^[a-z]{0,10}$/) && !e.metaKey && !e.ctrlKey && !e.altKey) {\n      setIsEditing(true);\n      setValue(value + key);\n    }\n  };\n\n  var handleFieldChangeComplete = function handleFieldChangeComplete(value) {\n    var onChange = rest.onChange;\n    setIsEditing(false);\n    setValue(value);\n    safeInvoke(onChange, value);\n\n    if (mainRef && isSelectable) {\n      mainRef.focus();\n    }\n  };\n\n  var handleFieldCancel = function handleFieldCancel() {\n    setIsEditing(false);\n  };\n\n  var handleClick = function handleClick() {\n    if (mainRef) mainRef.focus();\n  };\n\n  if (disabled) {\n    cursor = 'not-allowed';\n  } else if (isSelectable) {\n    cursor = 'default';\n  }\n\n  return React.createElement(React.Fragment, null, React.createElement(TextTableCell, _extends({\n    ref: setMainRef,\n    isSelectable: isSelectable,\n    onClick: handleClick,\n    onDoubleClick: handleDoubleClick,\n    onKeyDown: handleKeyDown,\n    cursor: cursor,\n    textProps: _objectSpread({\n      size: size,\n      opacity: disabled || !children && placeholder ? 0.5 : 1\n    }, textProps)\n  }, rest), children ? children : placeholder), isEditing && React.createElement(Portal, null, React.createElement(Stack, null, function (zIndex) {\n    return React.createElement(EditableCellField, {\n      zIndex: zIndex,\n      getTargetRef: function getTargetRef() {\n        return mainRef;\n      },\n      value: value,\n      onEscape: handleFieldCancel,\n      onChangeComplete: handleFieldChangeComplete,\n      onCancel: handleFieldCancel,\n      size: size\n    });\n  })));\n});\nEditableCell.propTypes = _objectSpread(_objectSpread({}, TableCell.propTypes), {}, {\n  /*\n   * Makes the TableCell focusable.\n   * Will add tabIndex={-1 || this.props.tabIndex}.\n   */\n  isSelectable: PropTypes.bool,\n\n  /**\n   * When true, the cell can't be edited.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Optional placeholder when children is falsy.\n   */\n  placeholder: PropTypes.node,\n\n  /**\n   * The size used for the TextTableCell and Textarea.\n   */\n  size: PropTypes.oneOf([300, 400]),\n\n  /**\n   * This is the value of the cell.\n   */\n  children: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * Function called when value changes. (value: string) => void.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * When true, the cell will initialize in the editing state.\n   */\n  autoFocus: PropTypes.bool\n});\nexport default EditableCell;","map":{"version":3,"sources":["../../../src/table/src/EditableCell.js"],"names":["emptyProps","EditableCell","memo","children","size","disabled","placeholder","isSelectable","textProps","autoFocus","rest","props","cursor","mainRef","setMainRef","useState","value","setValue","isEditing","setIsEditing","handleDoubleClick","handleKeyDown","key","e","handleFieldChangeComplete","onChange","safeInvoke","handleFieldCancel","handleClick","opacity","TableCell","PropTypes","bool"],"mappings":"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","sourcesContent":["import React, { memo, useState } from 'react'\nimport PropTypes from 'prop-types'\nimport { Portal } from '../../portal'\nimport { Stack } from '../../stack'\nimport safeInvoke from '../../lib/safe-invoke'\nimport TextTableCell from './TextTableCell'\nimport TableCell from './TableCell'\nimport EditableCellField from './EditableCellField'\n\nconst emptyProps = {}\n\nconst EditableCell = memo(function EditableCell(props) {\n  const {\n    children,\n    size = 300,\n    disabled,\n    placeholder,\n    isSelectable = true,\n    textProps = emptyProps,\n    autoFocus = false,\n    ...rest\n  } = props\n\n  let cursor = 'text'\n\n  const [mainRef, setMainRef] = useState()\n  const [value, setValue] = useState(children)\n  const [isEditing, setIsEditing] = useState(autoFocus)\n\n  const handleDoubleClick = () => {\n    if (disabled || !isSelectable) return\n\n    setIsEditing(true)\n  }\n\n  const handleKeyDown = e => {\n    if (disabled) return\n    const { key } = e\n\n    /**\n     * When the user presses a character on the keyboard, use that character\n     * as the value in the text field.\n     */\n    if (key === 'Enter' || key === 'Shift') {\n      setIsEditing(true)\n    } else if (\n      key.match(/^[a-z]{0,10}$/) &&\n      !e.metaKey &&\n      !e.ctrlKey &&\n      !e.altKey\n    ) {\n      setIsEditing(true)\n      setValue(value + key)\n    }\n  }\n\n  const handleFieldChangeComplete = value => {\n    const { onChange } = rest\n\n    setIsEditing(false)\n    setValue(value)\n\n    safeInvoke(onChange, value)\n\n    if (mainRef && isSelectable) {\n      mainRef.focus()\n    }\n  }\n\n  const handleFieldCancel = () => {\n    setIsEditing(false)\n  }\n\n  const handleClick = () => {\n    if (mainRef) mainRef.focus()\n  }\n\n  if (disabled) {\n    cursor = 'not-allowed'\n  } else if (isSelectable) {\n    cursor = 'default'\n  }\n\n  return (\n    <React.Fragment>\n      <TextTableCell\n        ref={setMainRef}\n        isSelectable={isSelectable}\n        onClick={handleClick}\n        onDoubleClick={handleDoubleClick}\n        onKeyDown={handleKeyDown}\n        cursor={cursor}\n        textProps={{\n          size,\n          opacity: disabled || (!children && placeholder) ? 0.5 : 1,\n          ...textProps\n        }}\n        {...rest}\n      >\n        {children ? children : placeholder}\n      </TextTableCell>\n      {isEditing && (\n        <Portal>\n          <Stack>\n            {zIndex => (\n              <EditableCellField\n                zIndex={zIndex}\n                getTargetRef={() => mainRef}\n                value={value}\n                onEscape={handleFieldCancel}\n                onChangeComplete={handleFieldChangeComplete}\n                onCancel={handleFieldCancel}\n                size={size}\n              />\n            )}\n          </Stack>\n        </Portal>\n      )}\n    </React.Fragment>\n  )\n})\n\nEditableCell.propTypes = {\n  /**\n   * Composes the TableCell component as the base.\n   */\n  ...TableCell.propTypes,\n\n  /*\n   * Makes the TableCell focusable.\n   * Will add tabIndex={-1 || this.props.tabIndex}.\n   */\n  isSelectable: PropTypes.bool,\n\n  /**\n   * When true, the cell can't be edited.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * Optional placeholder when children is falsy.\n   */\n  placeholder: PropTypes.node,\n\n  /**\n   * The size used for the TextTableCell and Textarea.\n   */\n  size: PropTypes.oneOf([300, 400]),\n\n  /**\n   * This is the value of the cell.\n   */\n  children: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n\n  /**\n   * Function called when value changes. (value: string) => void.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * When true, the cell will initialize in the editing state.\n   */\n  autoFocus: PropTypes.bool\n}\n\nexport default EditableCell\n"]},"metadata":{},"sourceType":"module"}