{"ast":null,"code":"import { Position } from '../../constants';\n/**\n * Function to create a Rect.\n * @param {Object} dimensions\n * @param {Number} dimensions.width\n * @param {Number} dimensions.height\n * @param {Object} position\n * @param {Number} position.left\n * @param {Number} position.top\n * @return {Object} Rect { width, height, left, top, right, bottom }\n */\n\nvar makeRect = function makeRect(_ref, _ref2) {\n  var width = _ref.width,\n      height = _ref.height;\n  var left = _ref2.left,\n      top = _ref2.top;\n  var ceiledLeft = Math.ceil(left);\n  var ceiledTop = Math.ceil(top);\n  return {\n    width: width,\n    height: height,\n    left: ceiledLeft,\n    top: ceiledTop,\n    right: ceiledLeft + width,\n    bottom: ceiledTop + height\n  };\n};\n/**\n * Function to flip a position upside down.\n * @param {Position} position\n * @return {Position} flipped position\n */\n\n\nvar flipHorizontal = function flipHorizontal(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n      return Position.BOTTOM_LEFT;\n\n    case Position.TOP:\n    default:\n      return Position.BOTTOM;\n\n    case Position.TOP_RIGHT:\n      return Position.BOTTOM_RIGHT;\n\n    case Position.BOTTOM_LEFT:\n      return Position.TOP_LEFT;\n\n    case Position.BOTTOM:\n      return Position.TOP;\n\n    case Position.BOTTOM_RIGHT:\n      return Position.TOP_RIGHT;\n  }\n};\n/**\n * Function that returns if position is aligned on top.\n * @param {Position} position\n * @return {Boolean}\n */\n\n\nvar isAlignedOnTop = function isAlignedOnTop(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n    case Position.TOP:\n    case Position.TOP_RIGHT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if position is aligned left or right.\n * @param {Position} position\n * @return {Boolean}\n */\n\n\nvar isAlignedHorizontal = function isAlignedHorizontal(position) {\n  switch (position) {\n    case Position.LEFT:\n    case Position.RIGHT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if a rect fits on bottom.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnBottom = function getFitsOnBottom(rect, viewport, viewportOffset) {\n  return rect.bottom < viewport.height - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on top.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnTop = function getFitsOnTop(rect, viewportOffset) {\n  return rect.top > viewportOffset;\n};\n/**\n * Function that returns if a rect fits on right.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnRight = function getFitsOnRight(rect, viewport, viewportOffset) {\n  return rect.right < viewport.width - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on left.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnLeft = function getFitsOnLeft(rect, viewportOffset) {\n  return rect.left > viewportOffset;\n};\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n * Function that returns the CSS `tranform-origin` property.\n * @param {Rect} rect\n * @param {Position} position\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Number} targetCenter - center of the target.\n * @return {String} transform origin\n */\n\n\nvar getTransformOrigin = function getTransformOrigin(_ref3) {\n  var rect = _ref3.rect,\n      position = _ref3.position,\n      dimensions = _ref3.dimensions,\n      targetCenter = _ref3.targetCenter;\n  var centerY = Math.round(targetCenter - rect.top);\n\n  if (position === Position.LEFT) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(dimensions.width, \"px \").concat(centerY, \"px\");\n  }\n\n  if (position === Position.RIGHT) {\n    /* Syntax: x-offset | y-offset */\n    return \"0px \".concat(centerY, \"px\");\n  }\n\n  var centerX = Math.round(targetCenter - rect.left);\n\n  if (isAlignedOnTop(position)) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(centerX, \"px \").concat(dimensions.height, \"px \");\n  }\n  /* Syntax: x-offset | y-offset */\n\n\n  return \"\".concat(centerX, \"px 0px \");\n};\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Number} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position, transformOrigin: string }\n */\n\n\nexport default function getFittedPosition(_ref4) {\n  var position = _ref4.position,\n      dimensions = _ref4.dimensions,\n      targetRect = _ref4.targetRect,\n      targetOffset = _ref4.targetOffset,\n      viewport = _ref4.viewport,\n      _ref4$viewportOffset = _ref4.viewportOffset,\n      viewportOffset = _ref4$viewportOffset === void 0 ? 8 : _ref4$viewportOffset;\n\n  var _getPosition = getPosition({\n    position: position,\n    dimensions: dimensions,\n    targetRect: targetRect,\n    targetOffset: targetOffset,\n    viewport: viewport,\n    viewportOffset: viewportOffset\n  }),\n      rect = _getPosition.rect,\n      finalPosition = _getPosition.position; // Push rect to the right if overflowing on the left side of the viewport.\n\n\n  if (rect.left < viewportOffset) {\n    rect.right += Math.ceil(Math.abs(rect.left - viewportOffset));\n    rect.left = Math.ceil(viewportOffset);\n  } // Push rect to the left if overflowing on the right side of the viewport.\n\n\n  if (rect.right > viewport.width - viewportOffset) {\n    var delta = Math.ceil(rect.right - (viewport.width - viewportOffset));\n    rect.left -= delta;\n    rect.right -= delta;\n  } // Push rect down if overflowing on the top side of the viewport.\n\n\n  if (rect.top < viewportOffset) {\n    rect.top += Math.ceil(Math.abs(rect.top - viewportOffset));\n    rect.bottom = Math.ceil(viewportOffset);\n  } // Push rect up if overflowing on the bottom side of the viewport.\n\n\n  if (rect.bottom > viewport.height - viewportOffset) {\n    var _delta = Math.ceil(rect.bottom - (viewport.height - viewportOffset));\n\n    rect.top -= _delta;\n    rect.bottom -= _delta;\n  }\n\n  var targetCenter = isAlignedHorizontal(position) ? targetRect.top + targetRect.height / 2 : targetRect.left + targetRect.width / 2;\n  var transformOrigin = getTransformOrigin({\n    rect: rect,\n    position: finalPosition,\n    dimensions: dimensions,\n    targetCenter: targetCenter\n  });\n  return {\n    rect: rect,\n    position: finalPosition,\n    transformOrigin: transformOrigin\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Object} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position }\n */\n\nfunction getPosition(_ref5) {\n  var position = _ref5.position,\n      dimensions = _ref5.dimensions,\n      targetRect = _ref5.targetRect,\n      targetOffset = _ref5.targetOffset,\n      viewport = _ref5.viewport,\n      _ref5$viewportOffset = _ref5.viewportOffset,\n      viewportOffset = _ref5$viewportOffset === void 0 ? 8 : _ref5$viewportOffset;\n  var isHorizontal = isAlignedHorizontal(position); // Handle left and right positions\n\n  if (isHorizontal) {\n    var leftRect = getRect({\n      position: Position.LEFT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var rightRect = getRect({\n      position: Position.RIGHT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var fitsOnLeft = getFitsOnLeft(leftRect, viewportOffset);\n    var fitsOnRight = getFitsOnRight(rightRect, viewport, viewportOffset);\n\n    if (position === Position.LEFT) {\n      if (fitsOnLeft) {\n        return {\n          position: position,\n          rect: leftRect\n        };\n      }\n\n      if (fitsOnRight) {\n        return {\n          position: Position.RIGHT,\n          rect: rightRect\n        };\n      }\n    }\n\n    if (position === Position.RIGHT) {\n      if (fitsOnRight) {\n        return {\n          position: position,\n          rect: rightRect\n        };\n      }\n\n      if (fitsOnLeft) {\n        return {\n          position: Position.LEFT,\n          rect: leftRect\n        };\n      }\n    } // Default to using the position with the most space\n\n\n    var spaceRight = Math.abs(viewport.width - viewportOffset - rightRect.right);\n    var spaceLeft = Math.abs(leftRect.left - viewportOffset);\n\n    if (spaceRight < spaceLeft) {\n      return {\n        position: Position.RIGHT,\n        rect: rightRect\n      };\n    }\n\n    return {\n      position: Position.LEFT,\n      rect: leftRect\n    };\n  }\n\n  var positionIsAlignedOnTop = isAlignedOnTop(position);\n  var topRect;\n  var bottomRect;\n\n  if (positionIsAlignedOnTop) {\n    topRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  } else {\n    topRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  }\n\n  var topRectFitsOnTop = getFitsOnTop(topRect, viewportOffset);\n  var bottomRectFitsOnBottom = getFitsOnBottom(bottomRect, viewport, viewportOffset);\n\n  if (positionIsAlignedOnTop) {\n    if (topRectFitsOnTop) {\n      return {\n        position: position,\n        rect: topRect\n      };\n    }\n\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: flipHorizontal(position),\n        rect: bottomRect\n      };\n    }\n  }\n\n  if (!positionIsAlignedOnTop) {\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: position,\n        rect: bottomRect\n      };\n    }\n\n    if (topRectFitsOnTop) {\n      return {\n        position: flipHorizontal(position),\n        rect: topRect\n      };\n    }\n  } // Default to most spacious if there is no fit.\n\n\n  var spaceBottom = Math.abs(viewport.height - viewportOffset - bottomRect.bottom);\n  var spaceTop = Math.abs(topRect.top - viewportOffset);\n\n  if (spaceBottom < spaceTop) {\n    return {\n      position: positionIsAlignedOnTop ? flipHorizontal(position) : position,\n      rect: bottomRect\n    };\n  }\n\n  return {\n    position: positionIsAlignedOnTop ? position : flipHorizontal(position),\n    rect: topRect\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @return {Rect} - Rect { width, height, left, top, right, bottom }\n */\n\n\nfunction getRect(_ref6) {\n  var position = _ref6.position,\n      targetOffset = _ref6.targetOffset,\n      dimensions = _ref6.dimensions,\n      targetRect = _ref6.targetRect;\n  var leftRect = targetRect.left + targetRect.width / 2 - dimensions.width / 2;\n  var alignedTopY = targetRect.top - dimensions.height - targetOffset;\n  var alignedBottomY = targetRect.bottom + targetOffset;\n  var alignedRightX = targetRect.right - dimensions.width;\n  var alignedLeftRightY = targetRect.top + targetRect.height / 2 - dimensions.height / 2;\n\n  switch (position) {\n    case Position.LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left - dimensions.width - targetOffset,\n        top: alignedLeftRightY\n      });\n\n    case Position.RIGHT:\n      return makeRect(dimensions, {\n        left: targetRect.right + targetOffset,\n        top: alignedLeftRightY\n      });\n\n    case Position.TOP:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedTopY\n      });\n\n    case Position.TOP_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedTopY\n      });\n\n    case Position.TOP_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedTopY\n      });\n\n    default:\n    case Position.BOTTOM:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedBottomY\n      });\n\n    case Position.BOTTOM_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedBottomY\n      });\n\n    case Position.BOTTOM_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedBottomY\n      });\n  }\n}","map":{"version":3,"sources":["../../../src/positioner/src/getPosition.js"],"names":["makeRect","width","height","left","top","ceiledLeft","Math","ceiledTop","right","bottom","flipHorizontal","Position","isAlignedOnTop","isAlignedHorizontal","getFitsOnBottom","rect","viewport","getFitsOnTop","getFitsOnRight","getFitsOnLeft","getTransformOrigin","position","dimensions","targetCenter","centerY","centerX","targetRect","targetOffset","viewportOffset","finalPosition","getPosition","delta","transformOrigin","isHorizontal","leftRect","getRect","rightRect","fitsOnLeft","fitsOnRight","spaceRight","spaceLeft","positionIsAlignedOnTop","topRect","bottomRect","topRectFitsOnTop","bottomRectFitsOnBottom","spaceBottom","spaceTop","alignedTopY","alignedBottomY","alignedRightX","alignedLeftRightY"],"mappings":"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","sourcesContent":["import { Position } from '../../constants'\n\n/**\n * Function to create a Rect.\n * @param {Object} dimensions\n * @param {Number} dimensions.width\n * @param {Number} dimensions.height\n * @param {Object} position\n * @param {Number} position.left\n * @param {Number} position.top\n * @return {Object} Rect { width, height, left, top, right, bottom }\n */\nconst makeRect = ({ width, height }, { left, top }) => {\n  const ceiledLeft = Math.ceil(left)\n  const ceiledTop = Math.ceil(top)\n  return {\n    width,\n    height,\n    left: ceiledLeft,\n    top: ceiledTop,\n    right: ceiledLeft + width,\n    bottom: ceiledTop + height\n  }\n}\n\n/**\n * Function to flip a position upside down.\n * @param {Position} position\n * @return {Position} flipped position\n */\nconst flipHorizontal = position => {\n  switch (position) {\n    case Position.TOP_LEFT:\n      return Position.BOTTOM_LEFT\n    case Position.TOP:\n    default:\n      return Position.BOTTOM\n    case Position.TOP_RIGHT:\n      return Position.BOTTOM_RIGHT\n    case Position.BOTTOM_LEFT:\n      return Position.TOP_LEFT\n    case Position.BOTTOM:\n      return Position.TOP\n    case Position.BOTTOM_RIGHT:\n      return Position.TOP_RIGHT\n  }\n}\n\n/**\n * Function that returns if position is aligned on top.\n * @param {Position} position\n * @return {Boolean}\n */\nconst isAlignedOnTop = position => {\n  switch (position) {\n    case Position.TOP_LEFT:\n    case Position.TOP:\n    case Position.TOP_RIGHT:\n      return true\n    default:\n      return false\n  }\n}\n\n/**\n * Function that returns if position is aligned left or right.\n * @param {Position} position\n * @return {Boolean}\n */\nconst isAlignedHorizontal = position => {\n  switch (position) {\n    case Position.LEFT:\n    case Position.RIGHT:\n      return true\n    default:\n      return false\n  }\n}\n\n/**\n * Function that returns if a rect fits on bottom.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\nconst getFitsOnBottom = (rect, viewport, viewportOffset) => {\n  return rect.bottom < viewport.height - viewportOffset\n}\n\n/**\n * Function that returns if a rect fits on top.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\nconst getFitsOnTop = (rect, viewportOffset) => {\n  return rect.top > viewportOffset\n}\n\n/**\n * Function that returns if a rect fits on right.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\nconst getFitsOnRight = (rect, viewport, viewportOffset) => {\n  return rect.right < viewport.width - viewportOffset\n}\n\n/**\n * Function that returns if a rect fits on left.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\nconst getFitsOnLeft = (rect, viewportOffset) => {\n  return rect.left > viewportOffset\n}\n\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n * Function that returns the CSS `tranform-origin` property.\n * @param {Rect} rect\n * @param {Position} position\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Number} targetCenter - center of the target.\n * @return {String} transform origin\n */\nconst getTransformOrigin = ({ rect, position, dimensions, targetCenter }) => {\n  const centerY = Math.round(targetCenter - rect.top)\n\n  if (position === Position.LEFT) {\n    /* Syntax: x-offset | y-offset */\n    return `${dimensions.width}px ${centerY}px`\n  }\n\n  if (position === Position.RIGHT) {\n    /* Syntax: x-offset | y-offset */\n    return `0px ${centerY}px`\n  }\n\n  const centerX = Math.round(targetCenter - rect.left)\n\n  if (isAlignedOnTop(position)) {\n    /* Syntax: x-offset | y-offset */\n    return `${centerX}px ${dimensions.height}px `\n  }\n\n  /* Syntax: x-offset | y-offset */\n  return `${centerX}px 0px `\n}\n\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Number} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position, transformOrigin: string }\n */\nexport default function getFittedPosition({\n  position,\n  dimensions,\n  targetRect,\n  targetOffset,\n  viewport,\n  viewportOffset = 8\n}) {\n  const { rect, position: finalPosition } = getPosition({\n    position,\n    dimensions,\n    targetRect,\n    targetOffset,\n    viewport,\n    viewportOffset\n  })\n\n  // Push rect to the right if overflowing on the left side of the viewport.\n  if (rect.left < viewportOffset) {\n    rect.right += Math.ceil(Math.abs(rect.left - viewportOffset))\n    rect.left = Math.ceil(viewportOffset)\n  }\n\n  // Push rect to the left if overflowing on the right side of the viewport.\n  if (rect.right > viewport.width - viewportOffset) {\n    const delta = Math.ceil(rect.right - (viewport.width - viewportOffset))\n    rect.left -= delta\n    rect.right -= delta\n  }\n\n  // Push rect down if overflowing on the top side of the viewport.\n  if (rect.top < viewportOffset) {\n    rect.top += Math.ceil(Math.abs(rect.top - viewportOffset))\n    rect.bottom = Math.ceil(viewportOffset)\n  }\n\n  // Push rect up if overflowing on the bottom side of the viewport.\n  if (rect.bottom > viewport.height - viewportOffset) {\n    const delta = Math.ceil(rect.bottom - (viewport.height - viewportOffset))\n    rect.top -= delta\n    rect.bottom -= delta\n  }\n\n  const targetCenter = isAlignedHorizontal(position)\n    ? targetRect.top + targetRect.height / 2\n    : targetRect.left + targetRect.width / 2\n\n  const transformOrigin = getTransformOrigin({\n    rect,\n    position: finalPosition,\n    dimensions,\n    targetCenter\n  })\n\n  return {\n    rect,\n    position: finalPosition,\n    transformOrigin\n  }\n}\n\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Object} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position }\n */\nfunction getPosition({\n  position,\n  dimensions,\n  targetRect,\n  targetOffset,\n  viewport,\n  viewportOffset = 8\n}) {\n  const isHorizontal = isAlignedHorizontal(position)\n\n  // Handle left and right positions\n  if (isHorizontal) {\n    const leftRect = getRect({\n      position: Position.LEFT,\n      dimensions,\n      targetRect,\n      targetOffset\n    })\n\n    const rightRect = getRect({\n      position: Position.RIGHT,\n      dimensions,\n      targetRect,\n      targetOffset\n    })\n\n    const fitsOnLeft = getFitsOnLeft(leftRect, viewportOffset)\n    const fitsOnRight = getFitsOnRight(rightRect, viewport, viewportOffset)\n\n    if (position === Position.LEFT) {\n      if (fitsOnLeft) {\n        return {\n          position,\n          rect: leftRect\n        }\n      }\n\n      if (fitsOnRight) {\n        return {\n          position: Position.RIGHT,\n          rect: rightRect\n        }\n      }\n    }\n\n    if (position === Position.RIGHT) {\n      if (fitsOnRight) {\n        return {\n          position,\n          rect: rightRect\n        }\n      }\n\n      if (fitsOnLeft) {\n        return {\n          position: Position.LEFT,\n          rect: leftRect\n        }\n      }\n    }\n\n    // Default to using the position with the most space\n    const spaceRight = Math.abs(\n      viewport.width - viewportOffset - rightRect.right\n    )\n    const spaceLeft = Math.abs(leftRect.left - viewportOffset)\n\n    if (spaceRight < spaceLeft) {\n      return {\n        position: Position.RIGHT,\n        rect: rightRect\n      }\n    }\n\n    return {\n      position: Position.LEFT,\n      rect: leftRect\n    }\n  }\n\n  const positionIsAlignedOnTop = isAlignedOnTop(position)\n  let topRect\n  let bottomRect\n\n  if (positionIsAlignedOnTop) {\n    topRect = getRect({\n      position,\n      dimensions,\n      targetRect,\n      targetOffset\n    })\n    bottomRect = getRect({\n      position: flipHorizontal(position),\n      dimensions,\n      targetRect,\n      targetOffset\n    })\n  } else {\n    topRect = getRect({\n      position: flipHorizontal(position),\n      dimensions,\n      targetRect,\n      targetOffset\n    })\n    bottomRect = getRect({\n      position,\n      dimensions,\n      targetRect,\n      targetOffset\n    })\n  }\n\n  const topRectFitsOnTop = getFitsOnTop(topRect, viewportOffset)\n\n  const bottomRectFitsOnBottom = getFitsOnBottom(\n    bottomRect,\n    viewport,\n    viewportOffset\n  )\n\n  if (positionIsAlignedOnTop) {\n    if (topRectFitsOnTop) {\n      return {\n        position,\n        rect: topRect\n      }\n    }\n\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: flipHorizontal(position),\n        rect: bottomRect\n      }\n    }\n  }\n\n  if (!positionIsAlignedOnTop) {\n    if (bottomRectFitsOnBottom) {\n      return {\n        position,\n        rect: bottomRect\n      }\n    }\n\n    if (topRectFitsOnTop) {\n      return {\n        position: flipHorizontal(position),\n        rect: topRect\n      }\n    }\n  }\n\n  // Default to most spacious if there is no fit.\n  const spaceBottom = Math.abs(\n    viewport.height - viewportOffset - bottomRect.bottom\n  )\n\n  const spaceTop = Math.abs(topRect.top - viewportOffset)\n\n  if (spaceBottom < spaceTop) {\n    return {\n      position: positionIsAlignedOnTop ? flipHorizontal(position) : position,\n      rect: bottomRect\n    }\n  }\n\n  return {\n    position: positionIsAlignedOnTop ? position : flipHorizontal(position),\n    rect: topRect\n  }\n}\n\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Rect} targetRect — the rect of the target.\n * @return {Rect} - Rect { width, height, left, top, right, bottom }\n */\nfunction getRect({ position, targetOffset, dimensions, targetRect }) {\n  const leftRect = targetRect.left + targetRect.width / 2 - dimensions.width / 2\n  const alignedTopY = targetRect.top - dimensions.height - targetOffset\n  const alignedBottomY = targetRect.bottom + targetOffset\n  const alignedRightX = targetRect.right - dimensions.width\n  const alignedLeftRightY =\n    targetRect.top + targetRect.height / 2 - dimensions.height / 2\n\n  switch (position) {\n    case Position.LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left - dimensions.width - targetOffset,\n        top: alignedLeftRightY\n      })\n    case Position.RIGHT:\n      return makeRect(dimensions, {\n        left: targetRect.right + targetOffset,\n        top: alignedLeftRightY\n      })\n    case Position.TOP:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedTopY\n      })\n    case Position.TOP_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedTopY\n      })\n    case Position.TOP_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedTopY\n      })\n    default:\n    case Position.BOTTOM:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedBottomY\n      })\n    case Position.BOTTOM_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedBottomY\n      })\n    case Position.BOTTOM_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedBottomY\n      })\n  }\n}\n"]},"metadata":{},"sourceType":"module"}